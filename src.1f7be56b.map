{"version":3,"sources":["../node_modules/onpushstate/index.js","../node_modules/isarray/index.js","../node_modules/path-to-regexp/index.js","../node_modules/hyperhtml-app/index.js","../node_modules/hyperhtml/cjs/shared/constants.js","../node_modules/hyperhtml/cjs/shared/poorlyfills.js","../node_modules/hyperhtml/cjs/classes/Component.js","../node_modules/hyperhtml/cjs/objects/Intent.js","../node_modules/hyperhtml/cjs/shared/easy-dom.js","../node_modules/hyperhtml/cjs/shared/re.js","../node_modules/hyperhtml/cjs/shared/features-detection.js","../node_modules/hyperhtml/cjs/shared/utils.js","../node_modules/hyperhtml/cjs/classes/Wire.js","../node_modules/hyperhtml/cjs/objects/Path.js","../node_modules/hyperhtml/cjs/objects/Style.js","../node_modules/hyperhtml/cjs/shared/domdiff.js","../node_modules/hyperhtml/cjs/objects/Updates.js","../node_modules/hyperhtml/cjs/hyper/render.js","../node_modules/hyperhtml/cjs/hyper/wire.js","../node_modules/hyperhtml/cjs/index.js","js/helper/signal.js","js/helper/is.js","js/helper/result.js","js/component/ArrowPad.js","js/component/Clock.js","js/component/List.js","js/component/Header.js","js/component/Link.js","js/App.js","index.js"],"names":["module","exports","send","el","type","payload","dispatchEvent","CustomEvent","recv","cb","addEventListener","val","constructor","def","require","Function","e","Component","result","args","props","action","setTimeout","setState","count","state","target","document","getElementById","bubbles","detail","text","Math","random","html","doAThing","Object","assign","tick","date","Date","toLocaleTimeString","ListItem","listItemStyle","item","li","listItems","map","$","for","tag","toUpperCase","listStyle","List","background","display","margin","padding","style","href","click","console","clog","log","d","root","app","bind","signal","ArrowPad","Clock","Header","Link","URI","App","fetch","then","b","json","filter","permalink","menu_index","sort","a","title","url","route","navigate","innerHTML","Array","fill","i"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DAA,OAAOC,OAAP,GAAiB;AACf;ACDFD,ADEE,OCFKC,OAAP,GAAiB,UAACU,GAAD,EAAMP,IAAN;AAAA,SAAeO,IAAIC,WAAJ,KAAoBR,IAAnC;AAAA,ACAjBJ,CDAA,MCAOC,OAAP,GAAiB,UAACU,GAAD,EAAME,GAAN,EAAc;AAC7B,MAAI;AACF,WAAO,CAACC,QAAQ,MAAR,EAAgBH,GAAhB,EAAqBI,QAArB,IAAiCJ,KAAjC,GAAyCA,GAA1C,KAAkDE,GAAzD;AACD,GAFD,CAEE,OAAOG,CAAP,EAAU;AACV,AFIFd,MARe,KEINW,GAAP,QFIGV,EARU,EAQNC,IARM,EAQAC,OARA,EAQS;AEHvB,AFICF,OAAGG,aAAH,CAAiB,IAAIC,WAAJ,CAAgBH,IAAhB,EAAsBC,OAAtB,CAAjB;AEHH,AFIE,CEVH,EFAiB;;AAWf;AACA;;;;;ASZFS,QAAQ,ONAcA,GMAtB,KNA8B,eAAR;AHkBpBN,IGlBMS,EHAS,gBAkBVd,EAlBU,CGATc,CHkBGb,IAlBM,EAkBAK,EAlBA,EAkBI;AACjBN,OAAGO,QInBeI,QAAQ,AJmB1B,CAAoBV,IAApB,EAA0BK,EAA1B,MInBkB;ADCtB,AHmBG,IGnBGS,ACDED,SDCOH,QAAQ,ICDfG,cDCO,CAAf;AHDiB,CAAjB;AGGAjB,ACDAA,ODCOC,ACDAA,ODCP,ACDA;ADCA,ACDA,eEFsBa,ADAAA,QCAQ,ADAA,eCAR,ADAA;ICAdG,ADAAA,qBCAAA,ADAAA;AFIN,ACDA,ACFF,eEDsBH,KJIRK,ACDAA,GGHgB,CJI5B,ACDA,EDCkB,ACDA,YGHE;AJIF,ACDA,AEFpB,IAAMkC,ACDEpC,ODCKH,QAAQ,MCDbG,EDCK,CAAb;AACA,ACDA,IFEMyB;AGHN,ALIoB,ACDA;AIFpB,AFGA1C,ACDAA,ODCOC,ACDAA,ODCP,ACDA;AJEI,ACDA,AEAJ,ACDA,AFCE,eGFoB4D,KHER1C,IAAZ,EAAkB,gGFCRC,ACDAA,KDCR,ACDA,GDCgBD,ACDAA,IDChB,ACDA;ADAgB,AEAA,IGFP2C,gBAALC;ALIL,ACAC,AEDF,ACDA,gBAAY5C,EDCAA,ECDZ,EDCA,ACDkB,EDCA;AEFpB,AJII,AEFgB,ACDA,AFAA,IGDd6C,IAAIrC,AJIAW,OAAO,CIJjB,QJIUA,IAAO,GAAM;ADJvB,ACKM,YAAKf,QAAL,CAAc,EAAEgB,MAAM,IAAIC,IAAJ,EAAR,EAAd;AIHNwB,ALFA,ACMM1C,AEJc,ACDA,AFChB,EGAF2C,IAAF,GAASD,EAAEpC,MJIMU,IAAX,EAAiB,EIJd,AJIH,CIJoB,MAAjB,CAAT,yFHAYlB,KAAR,GAAgBD,IAAhB;AGCJ,ALHA,ACOK,ACJD,KDCA,KCDKI,QAAL,CAAc,MAAKH,IFIZJ,CAPX,AEGI,EFIUK,MAPd,EAOsB;AKHtB,ALGsB,AGJlB,ACDA,AFDgB,IGGd6C,MAAMpD,QAAQ,eAAR,GAAZ,8EDFYM,IDCAA,CCDR,GAAgBD,CDChB,GAAgBA,ACDhB,IDCA;AFMAmB,AELA,ACDA,AFCD,UCAMf,ACDAA,QDCL,ACDA,CDCc,ACDA,MDCKH,ACDAA,KDCnB,ACDA;AJKAE,ACRgB,AEEA,ACDA,eCIQR,ELGb,MKHqB,eAAR;ALGb,ACEZ,AELA,ACDA,ICCKG,WLGa,OAAKM,GKHlBN,KLGa,CAAc,EAAEO,OAAO,EAAE,OAAKC,KAAL,CAAWD,KAAtB,EAAd,CAAN;AAAA,IKHI2C,GLGf,EAA+D,GAA/D,QKHeA;ALIf,ACVJ,AEEA,ACDA,WJSS5C,QAAL,CAAc,EAAEF,OEGT,OFHO,EAAd;AKFJ,ALGIH,ACXJ,AEEA,ACDA,AFaI,IGNEkD,SAAStD,ALGJE,EAAEU,MKHU,ALGnB,EAAiBC,SAASC,MKHf,CAAf,OLGqB,CAAwB,MAAxB,CAAjB,EAAkDtB,aAAlD,CACE,IAAIC,WAAJ,CAAgB,SAAhB,EAA2B;AKHjC,ALIQsB,ACbR,AEEA,ACDA,ICQMX,SAASJ,ILIE,IKJM,ALGU,QCItB,AEFA,ACKA,SCVI,CAAf;AACA,ALIQgB,ACGJ,AEFA,ACKA,AFJA,IGNEuC,SJOK,ACDA,EGNMvD,CLID,EAAEiB,ACGFG,ACDAA,IDCZ,ACDA,CGNqB,CLID,gBCMJ,ACHD,KGPF,AJUQT,ACHDA,CGPxB,IJUoB,ACHD,CDGYc,ACHDI,IDGV,CAAgBF,QCJhC,EAC4C,KAAKhB,GDGjC,EAHhB,ACA4C,CAAWmB,IADvD;AGLJ,ALGwB,ACSrB,ACJA,IGRG0B,QAAQxD,OLGgBkB,CKHR,ILGaC,MAAL,EAAN,OKHV,CAAd;AACA,ALEwB,ACdxB,AEiBI,ACKA,ICVEsC,OLEU,EKFDzD,AFKJ,ACKA,KDLKoB,ACKAA,GCVO,CFKnB,ACKA,kBDFa,ACIA,CCZF,CAAf,AFQmBoB,GCIG7B,KAAL,CAAWiC,GDJG,ECE3B,EAGY,GDLC,EAHb,ACQiBjC,EDHX,GCGM,CDHF4B,ACGaM,IDHjB,ACAN,CDAe,CCIA,KAAKlC,KAAL,CAAWmC,KAJ1B,EAKK,KAAKnC,KAAL,CAAWM,IALhB;ACTJ,ALDiC,ACZjC,AEuBUmB,ACMP,IChBGsB,GLDA,CADF,GKES1D,EFUE,IADI,EETE,kBAAR,CAAb;ALIG,ACjBH,AEwBUgC,ACvBV,mBDuBqB,KFZA,AEYKrB,ADjBL,KCiBA,CAAWqB,SAFb;AEPnB,ALdA,ACYI,AEYMM,ACxBV,AFOI,IGOEqB,MAAM,GJFDrC,ACLA,MCiBU,CFZHC,CEYKkB,KFZZ,CAAc,EAAd,CEYqB,CFZH,EIE7B,GJFkCnC,KAAvB,CAAP,EEYiB,EAA2BoC,QAAQ,CAAnC,EAAsCC,SAAS,CAA/C,EAHF;AHrBnB,ACaG,AEYOd,ACzBV,AFQMA,uBCiBmB,ADjBJ,CEFA,CDmBMY,SAAS,cAAX;AHzBzB,ACDA,AEsBmB,ACdf,AFAO,IGSLmB,GFKI,ADdN,CCSA,KCTO,gBJWA;AAAA,AGWR,ACrBGhB,AFEH,eEFU;AHTb,AEEA,ACQQH,mBAAS,cADJ;ACSX,ALEE,ACpBJ,AEEA,ACSQE,EHXgCxC,SAAxC,EDoBW,IKFK,CLEAiB,CITC,GJSb,kBACqB;AKHT,ALGS,AGnBzB,ACOa,SADF,MJamB,OAAKC,EGbd,MHaS,CAAcnB,CAAd,EAAiB,UAAjB,CAAL;AAAA,AGZrB,ACIEe,EFZiBd,KFmBnB,EAEqB,IGbd,CCIC,IALD;ACUK,ALIS,AGZnB6B,ACIAa,cAAM,CJQkB,EIdnB,EDEM,GHYkBxB,QAAL,CAAcnB,CAAd,EAAiB,QAAjB,CAAL;AAAA,AGbd,ACML4C,AFON5D,OFFI,AGXA,ADaGC,EFCkB,KEDzB,CEPa,iBAAM,CAAE;ACKjB0E,ALGqB,AGXtB,ACJQ,AFcX,OEdI,GCYSF,GAAT,ELG0B,OAAKtC,QAAL,CAAcnB,CAAd,EAAiB,CKFxC4D,IADH,CACQ,MLEkB,CAAL;AKFb,ALEa,AGrBzB,ACeG,OJGC,EAIqB,IKHRC,EAAEC,IAAF,EAAL;AAAA,ALGa,AIvBzB,AFsBE,KGHE,EAEGF,IAFH,CAEQ,GLEkB,CEDhBzD,IAAZ,EFCiCgB,AEDf,QFCU,CAAcnB,CAAd,EAAiB,WAAjB,CAAL;AKFb,ALEa,AGtBzB,ADqBoB,OFHhB,EAKoB,IKFhB6D,CLEqBpD,CKDlBsD,ILCa,CAAW1D,CKF3B,CACU,ILJd,EAMgB,KAAKI,KAAL,CAAWD,KAN3B;AKIc,ALIf,AG1BH,ACDA,EDCsCP,SAAtC,IEsBuB4D,EAAEG,SAAF,IAAeH,EAAEI,UAAF,IAAgB,CAApC;AAAA,ALvBlB,AIAA,AFsBoB,EEtBgBhE,KCsB5B,EAEGiE,EDxBX,ECsBQ,CAEQ,UAACC,CAAD,EAAIN,CAAJ;AAAA,ALxBhB,eKwB0BM,EAAEF,UAAF,GAAeJ,EAAEI,UAA3B;AAAA,ALxBhB,AEuBI,OGDI,EAGGlC,GAHH,CAGO,WLrBM,4FEmBT3B,KAAR,GAAgBD,IAAhB;AGEW,ALpBX,AEmBA,aFnBOiB,EKoBU,KLpBHC,MAAP,CAAc,EAAEb,OAAO,CAAT,EAAd,EAA4B,KAAKJ,KAAjC,CAAP;AKqBQwB,ALpBT,AEmBC,gBGCc4B,KAAKvB,GAAL,CAAS;AACblB,AL3Bd,AE0BI,kBGCgB8C,EAAEO,KADK;AAEbzB,AHDV,kBGCgBkB,EAAEQ,GAFK;AAGbzB,AL7Bd,AE4BI,mBGCiB,kBAAK;AACV,AL9BhB,AE6BI,EF7BoC3C,SAAxC;AK+BgB,AHDZ;AGEY,AHDZ;AGEY6C,AHDZ,mBGCiB9C,CAAL;AACA,AHDZ,oBGCiBO,QAAL,CAAc,EAAE+D,OAAOT,EAAEQ,GAAX,EAAd;AACAnB,AHDZ,kBGCgBqB,QAAJ,CAAaV,EAAEQ,GAAf;AACD,AHdK;AGIO,AHSxB,WGTe;AADG,SAAN;AAAA,AHJf,OGCQ,CADI;AAAA,AHAZ,KGFI,EAqBGT,IArBH,CAqBQ,aAAK;AACT,AHpBR,YGoBarD,QAAL,CAAc,EAAEuB,MHOb,KGPwB+B,CAAb,EAAd;AACD,AHMI,KG7BP;AAwBAT,WAAO5D,IAAP,CAAYwD,EAAEC,IAAd,EAAoB,UAApB,EAAgC,aAAK;AACnCH,AHKF,WGLO,UAAL,EAAiB5C,OAAOF,EAAEc,MAAF,CAASwD,KAAhB,CAAjB;AACAxB,WAAK,WAAL,EAAkB5C,OAAO,MAAKO,KAAL,CAAWqB,SAAlB,CAAlB;AACA,AHKF,UAAMD,KAAK,KAAKpB,KAAL,CAAWqB,SAAX,CAAqBC,GAArB,CAAyB,aAAK;AGJxC,AHKCC,KGTF,KHSIL,aAAF,GAAkB,OAAKlB,KAAL,CAAWkB,aAA7B;AGnCU;AA+Bb,AHMG,eAAOD,SAASO,GAAT,CAAaD,CAAb,CAAP;AACD,OAJU,CAAX;;AAMA,aAAO,KAAKvB,KAAL,CAAWyB,GAAX,CAAeC,WAAf,OAAiC,IAAjC,GACH,KAAKjB,IADF,mBACoB,KAAKT,KAAL,CAAW2B,SAD/B,EAC6CP,EAD7C,IAEH,KAAKX,IAFF,mBAEoB,KAAKT,KAAL,CAAW2B,SAF/B,EAE6CP,EAF7C,CAAP;AAGD,6BGaQ;AACP,AHrDJ,aGqDW,KAAKX,IAAZ,kBACE,IAAIqC,MAAJ,CAAW,EAAEzB,WAAW,KAAKrB,KAAL,CAAWqB,SAAxB,EAAX,CADF,EAEK,KAAKrB,KAAL,CAAW6D,KAFhB,EAII,EAAEpD,MAAM,KAAKT,KAAL,CAAWS,IAAnB,EAJJ,EAKI,IAAImC,QAAJ,CAAa,EAAEhD,QAAQ,MAAV,EAAb,CALJ,EAMI,IAAIiD,KAAJ,CAAU,EAAE/B,MAAM,IAAIC,IAAJ,EAAR,EAAV,CANJ;AASD,AH9DH;AAAA,wBAgBqB;AACjB,aACE,KAAKpB,KAAL,IAAc;AACZ8B,aAAK,IADO,OGWC;AAAA,AHTbJ,mBAAW,EAFC;AAGZM,mBAAW,EAHC;AGYhB,AHRIT,aGQG,UHRY;AGSjB2C,AHbc,OADhB,QGcS,GADF;AAELpD,AHPH,cGOS8B,EAAEpC,cAAF,CAAiB,SAAjB,EAA4B4D,SAF7B;AAGL1C,AHjCN,mBGiCiB2C,MAAM,CAAN,EACRC,IADQ,GAER3C,GAFQ,CAEJ,UAACoC,CAAD,EAAIQ,CAAJ;AAAA,iBAAW;AACd/C,AHpCV,kBGoCgB4B,KAAKvB,GAAL,CAAS;AACblB,AHrCZ,EAAoCd,SAApC,eGqCsB0E,CADG;AAEbhC,0BAAUgC,CAFG;AAGb/B,qBAAO,kBAAK;AACV;AACA;AACA;AACAE,qBAAK9C,CAAL;AACA,uBAAKO,QAAL,CAAc,EAAE+D,aAAWK,CAAb,EAAd;AACAzB,oBAAIqB,QAAJ,OAAiBI,CAAjB;AACD;AAVY,aAAT;AADQ,WAAX;AAAA,SAFI;AAHN,OAAP;AAoBD;;;;EAvDe1E;;AAsElBkD,KAAKH,EAAEC,IAAP,oBAAe,IAAIS,GAAJ,EAAf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA","file":"src.1f7be56b.map","sourceRoot":"src","sourcesContent":["/*! (C) 2017 Andrea Giammarchi - @WebReflection - ISC License */\n/**\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\ndocument.addEventListener('click', function (e) {\n  // find the link node\n  var target = e.target;\n  var closest = target.closest || function (A) {\n    while (target && target.nodeName !== A) target = target.parentNode;\n    return target;\n  };\n  var anchor = closest.call(target, 'A');\n  if (\n    // it was found\n    anchor &&\n    // it's for the current page\n    /^(?:_self)?$/i.test(anchor.target) &&\n    // it's not a download\n    !anchor.hasAttribute('download') &&\n    // it's not a resource handled externally\n    anchor.getAttribute('rel') !== 'external'\n  ) {\n    // all states are simply fully resolved URLs\n    // pushstate will be the new page with old one as state\n    // popstate will be old page with previous one as state.\n    var next = new URL(anchor.href);\n    var curr = location;\n    // only if in the same origin\n    if (next.origin === curr.origin) {\n      // verify it's not just an anchor change\n      var redirect = next.pathname + next.search;\n      var hash = next.hash;\n      var scrollIntoView = true;\n      // in every case prevent the default action\n      e.preventDefault();\n      // but don't stop propagation, other listeners\n      // might want to be triggered regardless the history\n      if (redirect === (curr.pathname + curr.search)) {\n        // anchors should do what anchors do, only if valid\n        // https://www.w3.org/TR/html4/types.html#type-name\n        if (/^#[a-z][a-z0-9.:_-]+$/i.test(hash)) {\n          var target = document.querySelector(\n            hash + ',[name=\"' + hash.slice(1) + '\"]'\n          );\n          if (target) {\n            // verify if other listeners tried to prevent the default\n            e.preventDefault = function () { scrollIntoView = false; };\n            // after this event has captured and bubbled the DOM\n            setTimeout(function () {\n              // if nobody else prevented the default\n              // simulate what an anchor would've done\n              if (scrollIntoView) target.scrollIntoView(true);\n            });\n          }\n        }\n        // replace the history to ignore the popstate on anchor\n        history.replaceState(history.state, document.title, redirect + hash);\n      } else {\n        // trigger a new pushstate notification\n        var evt = new CustomEvent('pushstate');\n        evt.state = curr.href;\n        // being sure it happens after so the new location should be available\n        setTimeout(function () {\n          // dispatch the event\n          dispatchEvent(evt);\n          // also trigger Level 0 if possible\n          if (window.onpushstate) onpushstate(evt);\n        });\n        history.pushState(evt.state, document.title, redirect + hash);\n      }\n    }\n  }\n}, true);\n","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n","var isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = options && options.delimiter || '/'\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      keys.push(token)\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/')\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n","var hyperHTMLApp = (function () {'use strict';\n\n  var onpushstate = require('onpushstate');\n  var path2regexp = require('path-to-regexp');\n  var app = HyperHTMLApplication.prototype;\n\n  app.get = function get(path) {\n    for (var\n      keys = [],\n      re = asPath2RegExp(path, keys),\n      info = this._paths[re] || (this._paths[re] = {\n        keys: keys,\n        cb: [],\n        re: re\n      }),\n      i = 1, length = arguments.length;\n      i < length; i++\n    ) {\n      info.cb.push(arguments[i]);\n    }\n    return this;\n  };\n\n  app.delete = function del(path) {\n    for (var\n      re = asPath2RegExp(path, []),\n      info = this._paths[re],\n      i = 1, length = arguments.length;\n      i < length; i++\n    ) {\n      var cb = arguments[i];\n      var index = info ? info.cb.lastIndexOf(cb) : -1;\n      if (-1 < index) info.cb.splice(index, 1);\n    }\n    return this;\n  };\n\n  app.use = function use(mount, cb) {\n    for (var\n      paths = [].concat(mount),\n      i = 0, length = paths.length;\n      i < length; i++\n    ) {\n      this.get(paths[i], cb);\n    }\n    return this;\n  };\n\n  app.param = function param(name, cb) {\n    for (var\n      names = [].concat(name),\n      i = 0, length = names.length;\n      i < length; i++\n    ) {\n      this._params[names[i]] = cb;\n    }\n    return this;\n  };\n\n  app.navigate = function navigate(pathname, options) {\n    switch (true) {\n      case !!options:\n        switch (true) {\n          case !!options.replace:\n          case !!options.replaceState:\n            history.replaceState(history.state, document.title, pathname);\n            break;\n        }\n        break;\n      case pathname === (location.pathname + location.search):\n        this.handleEvent({type: 'samestate'});\n        break;\n      default:\n        var doc = document;\n        var html = doc.documentElement;\n        var navigator = doc.createElement('a');\n        navigator.href = pathname;\n        navigator.onclick = remove;\n        html.insertBefore(navigator, html.firstChild);\n        navigator.click();\n        break;\n    }\n    return this;\n  };\n\n  app.handleEvent = function handleEvent(e) {\n    var paths = this._paths;\n    for (var key in paths) {\n      if (paths.hasOwnProperty(key)) {\n        var info = paths[key];\n        var match = info.re.exec(location.pathname);\n        if (match) {\n          var invoked = [];\n          var keys = [];\n          var params = this._params;\n          var ctx = {\n            params: createParams(match, info.keys),\n            type: e.type\n          };\n          var i = 0;\n          var length = info.cb.length;\n          for (key in ctx.params) {\n            if (params.hasOwnProperty(key)) {\n              keys.push(key);\n            }\n          }\n          (function param() {\n            if (keys.length) {\n              key = keys.shift();\n              params[key](ctx, param, ctx.params[key]);\n            } else {\n              (function next() {\n                if (i < length) {\n                  var cb = info.cb[i++];\n                  if (invoked.lastIndexOf(cb) < 0) {\n                    invoked.push(cb);\n                    cb(ctx, next);\n                  } else {\n                    next();\n                  }\n                }\n              }());\n            }\n          }());\n          return;\n        }\n      }\n    }\n  };\n\n  function asPath2RegExp(path, keys) {\n    if (typeof path !== 'string') {\n      path = path.toString();\n      path = path.slice(1, path.lastIndexOf('/'));\n    }\n    return path2regexp(path, keys);\n  }\n\n  function createParams(match, keys) {\n    for (var\n      value,\n      params = {},\n      i = 1,\n      length = match.length;\n      i < length; i++\n    ) {\n      value = match[i];\n      if (value) params[keys[i - 1].name] = value;\n    }\n    return params;\n  }\n\n  function remove() {\n    this.parentNode.removeChild(this);\n  }\n\n  function HyperHTMLApplication() {\n    this._params = {};\n    this._paths = {};\n    global.addEventListener('popstate', this, false);\n    global.addEventListener('pushstate', this, false);\n  }\n\n  return function hyperHTMLApp() {\n    return new HyperHTMLApplication();\n  };\n\n}());\n\nmodule.exports = (global.hyperHTML || {}).app = hyperHTMLApp;","'use strict';\nconst G = document.defaultView;\nexports.G = G;\n\n// Node.CONSTANTS\n// 'cause some engine has no global Node defined\n// (i.e. Node, NativeScript, basicHTML ... )\nconst ELEMENT_NODE = 1;\nexports.ELEMENT_NODE = ELEMENT_NODE;\nconst ATTRIBUTE_NODE = 2;\nexports.ATTRIBUTE_NODE = ATTRIBUTE_NODE;\nconst TEXT_NODE = 3;\nexports.TEXT_NODE = TEXT_NODE;\nconst COMMENT_NODE = 8;\nexports.COMMENT_NODE = COMMENT_NODE;\nconst DOCUMENT_FRAGMENT_NODE = 11;\nexports.DOCUMENT_FRAGMENT_NODE = DOCUMENT_FRAGMENT_NODE;\n\n// HTML related constants\nconst VOID_ELEMENTS = /^area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr$/i;\nexports.VOID_ELEMENTS = VOID_ELEMENTS;\n\n// SVG related constants\nconst OWNER_SVG_ELEMENT = 'ownerSVGElement';\nexports.OWNER_SVG_ELEMENT = OWNER_SVG_ELEMENT;\nconst SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nexports.SVG_NAMESPACE = SVG_NAMESPACE;\n\n// Custom Elements / MutationObserver constants\nconst CONNECTED = 'connected';\nexports.CONNECTED = CONNECTED;\nconst DISCONNECTED = 'dis' + CONNECTED;\nexports.DISCONNECTED = DISCONNECTED;\n\n// hyperHTML related constants\nconst EXPANDO = '_hyper: ';\nexports.EXPANDO = EXPANDO;\nconst SHOULD_USE_TEXT_CONTENT = /^style|textarea$/i;\nexports.SHOULD_USE_TEXT_CONTENT = SHOULD_USE_TEXT_CONTENT;\nconst UID = EXPANDO + ((Math.random() * new Date) | 0) + ';';\nexports.UID = UID;\nconst UIDC = '<!--' + UID + '-->';\nexports.UIDC = UIDC;\n","'use strict';\nconst {G, UID} = require('./constants.js');\n\n// you know that kind of basics you need to cover\n// your use case only but you don't want to bloat the library?\n// There's even a package in here:\n// https://www.npmjs.com/package/poorlyfills\n\n// used to dispatch simple events\nlet Event = G.Event;\ntry {\n  new Event('Event');\n} catch(o_O) {\n  Event = function (type) {\n    const e = document.createEvent('Event');\n    e.initEvent(type, false, false);\n    return e;\n  };\n}\nexports.Event = Event;\n\n// used to store template literals\n/* istanbul ignore next */\nconst Map = G.Map || function Map() {\n  const keys = [], values = [];\n  return {\n    get(obj) {\n      return values[keys.indexOf(obj)];\n    },\n    set(obj, value) {\n      values[keys.push(obj) - 1] = value;\n    }\n  };\n};\nexports.Map = Map;\n\n// used to store wired content\nlet ID = 0;\nconst WeakMap = G.WeakMap || function WeakMap() {\n  const key = UID + ID++;\n  return {\n    get(obj) { return obj[key]; },\n    set(obj, value) {\n      Object.defineProperty(obj, key, {\n        configurable: true,\n        value\n      });\n    }\n  };\n};\nexports.WeakMap = WeakMap;\n\n// used to store hyper.Components\nconst WeakSet = G.WeakSet || function WeakSet() {\n  const wm = new WeakMap;\n  return {\n    add(obj) { wm.set(obj, true); },\n    has(obj) { return wm.get(obj) === true; }\n  };\n};\nexports.WeakSet = WeakSet;\n\n// used to be sure IE9 or older Androids work as expected\nconst isArray = Array.isArray || (toString =>\n  arr => toString.call(arr) === '[object Array]'\n)({}.toString);\nexports.isArray = isArray;\n\nconst trim = UID.trim || function () {\n  return this.replace(/^\\s+|\\s+$/g, '');\n};\nexports.trim = trim;\n","'use strict';\nconst { Map, WeakMap } = require('../shared/poorlyfills.js');\n\n// hyperHTML.Component is a very basic class\n// able to create Custom Elements like components\n// including the ability to listen to connect/disconnect\n// events via onconnect/ondisconnect attributes\n// Components can be created imperatively or declaratively.\n// The main difference is that declared components\n// will not automatically render on setState(...)\n// to simplify state handling on render.\nfunction Component() {\n  return this; // this is needed in Edge !!!\n}\nObject.defineProperty(exports, '__esModule', {value: true}).default = Component\n\n// Component is lazily setup because it needs\n// wire mechanism as lazy content\nfunction setup(content) {\n  // there are various weakly referenced variables in here\n  // and mostly are to use Component.for(...) static method.\n  const children = new WeakMap;\n  const create = Object.create;\n  const createEntry = (wm, id, component) => {\n    wm.set(id, component);\n    return component;\n  };\n  const get = (Class, info, context, id) => {\n    const relation = info.get(Class) || relate(Class, info);\n    switch (typeof id) {\n      case 'object':\n      case 'function':\n        const wm = relation.w || (relation.w = new WeakMap);\n        return wm.get(id) || createEntry(wm, id, new Class(context));\n      default:\n        const sm = relation.p || (relation.p = create(null));\n        return sm[id] || (sm[id] = new Class(context));\n    }\n  };\n  const relate = (Class, info) => {\n    const relation = {w: null, p: null};\n    info.set(Class, relation);\n    return relation;\n  };\n  const set = context => {\n    const info = new Map;\n    children.set(context, info);\n    return info;\n  };\n  // The Component Class\n  Object.defineProperties(\n    Component,\n    {\n      // Component.for(context[, id]) is a convenient way\n      // to automatically relate data/context to children components\n      // If not created yet, the new Component(context) is weakly stored\n      // and after that same instance would always be returned.\n      for: {\n        configurable: true,\n        value(context, id) {\n          return get(\n            this,\n            children.get(context) || set(context),\n            context,\n            id == null ?\n              'default' : id\n          );\n        }\n      }\n    }\n  );\n  Object.defineProperties(\n    Component.prototype,\n    {\n      // all events are handled with the component as context\n      handleEvent: {value(e) {\n        const ct = e.currentTarget;\n        this[\n          ('getAttribute' in ct && ct.getAttribute('data-call')) ||\n          ('on' + e.type)\n        ](e);\n      }},\n      // components will lazily define html or svg properties\n      // as soon as these are invoked within the .render() method\n      // Such render() method is not provided by the base class\n      // but it must be available through the Component extend.\n      // Declared components could implement a\n      // render(props) method too and use props as needed.\n      html: lazyGetter('html', content),\n      svg: lazyGetter('svg', content),\n      // the state is a very basic/simple mechanism inspired by Preact\n      state: lazyGetter('state', function () { return this.defaultState; }),\n      // it is possible to define a default state that'd be always an object otherwise\n      defaultState: {get() { return {}; }},\n      // setting some property state through a new object\n      // or a callback, triggers also automatically a render\n      // unless explicitly specified to not do so (render === false)\n      setState: {value(state, render) {\n        const target = this.state;\n        const source = typeof state === 'function' ? state.call(this, target) : state;\n        for (const key in source) target[key] = source[key];\n        if (render !== false) this.render();\n        return this;\n      }}\n    }\n  );\n}\nexports.setup = setup\n\n// instead of a secret key I could've used a WeakMap\n// However, attaching a property directly will result\n// into better performance with thousands of components\n// hanging around, and less memory pressure caused by the WeakMap\nconst lazyGetter = (type, fn) => {\n  const secret = '_' + type + '$';\n  return {\n    get() {\n      return this[secret] || (this[type] = fn.call(this, type));\n    },\n    set(value) {\n      Object.defineProperty(this, secret, {configurable: true, value});\n    }\n  };\n};\n","'use strict';\nconst intents = {};\nconst keys = [];\nconst hasOwnProperty = intents.hasOwnProperty;\n\nlet length = 0;\n\nObject.defineProperty(exports, '__esModule', {value: true}).default = {\n\n  // hyperHTML.define('intent', (object, update) => {...})\n  // can be used to define a third parts update mechanism\n  // when every other known mechanism failed.\n  // hyper.define('user', info => info.name);\n  // hyper(node)`<p>${{user}}</p>`;\n  define: (intent, callback) => {\n    if (!(intent in intents)) {\n      length = keys.push(intent);\n    }\n    intents[intent] = callback;\n  },\n\n  // this method is used internally as last resort\n  // to retrieve a value out of an object\n  invoke: (object, callback) => {\n    for (let i = 0; i < length; i++) {\n      let key = keys[i];\n      if (hasOwnProperty.call(object, key)) {\n        return intents[key](object[key], callback);\n      }\n    }\n  }\n};\n","'use strict';\n// these are tiny helpers to simplify most common operations needed here\nconst create = (node, type) => doc(node).createElement(type);\nexports.create = create;\nconst doc = node => node.ownerDocument || node;\nexports.doc = doc;\nconst fragment = node => doc(node).createDocumentFragment();\nexports.fragment = fragment;\nconst text = (node, text) => doc(node).createTextNode(text);\nexports.text = text;\n","'use strict';\n// TODO:  I'd love to code-cover RegExp too here\n//        these are fundamental for this library\n\nconst spaces = ' \\\\f\\\\n\\\\r\\\\t';\nconst almostEverything = '[^ ' + spaces + '\\\\/>\"\\'=]+';\nconst attrName = '[ ' + spaces + ']+' + almostEverything;\nconst tagName = '<([A-Za-z]+[A-Za-z0-9:_-]*)((?:';\nconst attrPartials = '(?:=(?:\\'[^\\']*?\\'|\"[^\"]*?\"|<[^>]*?>|' + almostEverything + '))?)';\n\nconst attrSeeker = new RegExp(\n  tagName + attrName + attrPartials + '+)([ ' + spaces + ']*/?>)',\n  'g'\n);\n\nconst selfClosing = new RegExp(\n  tagName + attrName + attrPartials + '*)([ ' + spaces + ']*/>)',\n  'g'\n);\n\nexports.attrName = attrName;\nexports.attrSeeker = attrSeeker;\nexports.selfClosing = selfClosing;\n","'use strict';\nconst {create, fragment, text} = require('./easy-dom.js');\n\nconst testFragment = fragment(document);\n\n// DOM4 node.append(...many)\nconst hasAppend = 'append' in testFragment;\nexports.hasAppend = hasAppend;\n\n// detect old browsers without HTMLTemplateElement content support\nconst hasContent = 'content' in create(document, 'template');\nexports.hasContent = hasContent;\n\n// IE 11 has problems with cloning templates: it \"forgets\" empty childNodes\ntestFragment.appendChild(text(testFragment, 'g'));\ntestFragment.appendChild(text(testFragment, ''));\nconst hasDoomedCloneNode = testFragment.cloneNode(true).childNodes.length === 1;\nexports.hasDoomedCloneNode = hasDoomedCloneNode;\n\n// old browsers need to fallback to cloneNode\n// Custom Elements V0 and V1 will work polyfilled\n// but native implementations need importNode instead\n// (specially Chromium and its old V0 implementation)\nconst hasImportNode = 'importNode' in document;\nexports.hasImportNode = hasImportNode;\n","'use strict';\nconst {attrName, attrSeeker} = require('./re.js');\n\nconst {\n  G,\n  OWNER_SVG_ELEMENT,\n  SVG_NAMESPACE,\n  UID,\n  UIDC\n} = require('./constants.js');\n\nconst {\n  hasAppend,\n  hasContent,\n  hasDoomedCloneNode,\n  hasImportNode\n} = require('./features-detection.js');\n\nconst {create, doc, fragment} = require('./easy-dom.js');\n\n// appends an array of nodes\n// to a generic node/fragment\n// When available, uses append passing all arguments at once\n// hoping that's somehow faster, even if append has more checks on type\nconst append = hasAppend ?\n  (node, childNodes) => {\n    node.append.apply(node, childNodes);\n  } :\n  (node, childNodes) => {\n    const length = childNodes.length;\n    for (let i = 0; i < length; i++) {\n      node.appendChild(childNodes[i]);\n    }\n  };\nexports.append = append;\n\nconst findAttributes = new RegExp('(' + attrName + '=)([\\'\"]?)' + UIDC + '\\\\2', 'gi');\nconst comments = ($0, $1, $2, $3) =>\n  '<' + $1 + $2.replace(findAttributes, replaceAttributes) + $3;\nconst replaceAttributes = ($0, $1, $2) => $1 + ($2 || '\"') + UID + ($2 || '\"');\n\n// given a node and a generic HTML content,\n// create either an SVG or an HTML fragment\n// where such content will be injected\nconst createFragment = (node, html) =>\n  (OWNER_SVG_ELEMENT in node ?\n    SVGFragment :\n    HTMLFragment\n  )(node, html.replace(attrSeeker, comments));\nexports.createFragment = createFragment;\n\n// IE/Edge shenanigans proof cloneNode\n// it goes through all nodes manually\n// instead of relying the engine to suddenly\n// merge nodes together\nconst cloneNode = hasDoomedCloneNode ?\n  node => {\n    const clone = node.cloneNode();\n    const childNodes = node.childNodes ||\n                      // this is an excess of caution\n                      // but some node, in IE, might not\n                      // have childNodes property.\n                      // The following fallback ensure working code\n                      // in older IE without compromising performance\n                      // or any other browser/engine involved.\n                      /* istanbul ignore next */\n                      [];\n    const length = childNodes.length;\n    for (let i = 0; i < length; i++) {\n      clone.appendChild(cloneNode(childNodes[i]));\n    }\n    return clone;\n  } :\n  // the following ignore is due code-coverage\n  // combination of not having document.importNode\n  // but having a working node.cloneNode.\n  // This shenario is common on older Android/WebKit browsers\n  // but basicHTML here tests just two major cases:\n  // with document.importNode or with broken cloneNode.\n  /* istanbul ignore next */\n  node => node.cloneNode(true);\n\n// used to import html into fragments\nconst importNode = hasImportNode ?\n  (doc, node) => doc.importNode(node, true) :\n  (doc, node) => cloneNode(node)\nexports.importNode = importNode\n\n// just recycling a one-off array to use slice\n// in every needed place\nconst slice = [].slice;\nexports.slice = slice;\n\n// lazy evaluated, returns the unique identity\n// of a template literal, as tempalte literal itself.\n// By default, ES2015 template literals are unique\n// tag`a${1}z` === tag`a${2}z`\n// even if interpolated values are different\n// the template chunks are in a frozen Array\n// that is identical each time you use the same\n// literal to represent same static content\n// around its own interpolations.\nconst unique = template => TL(template);\nexports.unique = unique;\n\n// TL returns a unique version of the template\n// it needs lazy feature detection\n// (cannot trust literals with transpiled code)\nlet TL = template => {\n  if (\n    // TypeScript template literals are not standard\n    template.propertyIsEnumerable('raw') ||\n    (\n      // Firefox < 55 has not standard implementation neither\n      /Firefox\\/(\\d+)/.test((G.navigator || {}).userAgent) &&\n      parseFloat(RegExp.$1) < 55\n    )\n  ) {\n    // in these cases, address templates once\n    const templateObjects = {};\n    // but always return the same template\n    TL = template => {\n      const key = '_' + template.join(UID);\n      return templateObjects[key] || (\n        templateObjects[key] = template\n      );\n    };\n  }\n  else {\n    // make TL an identity like function\n    TL = template => template;\n  }\n  return TL(template);\n};\n\n// create document fragments via native template\n// with a fallback for browsers that won't be able\n// to deal with some injected element such <td> or others\nconst HTMLFragment = hasContent ?\n  (node, html) => {\n    const container = create(node, 'template');\n    container.innerHTML = html;\n    return container.content;\n  } :\n  (node, html) => {\n    const container = create(node, 'template');\n    const content = fragment(node);\n    if (/^[^\\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(html)) {\n      const selector = RegExp.$1;\n      container.innerHTML = '<table>' + html + '</table>';\n      append(content, slice.call(container.querySelectorAll(selector)));\n    } else {\n      container.innerHTML = html;\n      append(content, slice.call(container.childNodes));\n    }\n    return content;\n  };\n\n// creates SVG fragment with a fallback for IE that needs SVG\n// within the HTML content\nconst SVGFragment = hasContent ?\n  (node, html) => {\n    const content = fragment(node);\n    const container = doc(node).createElementNS(SVG_NAMESPACE, 'svg');\n    container.innerHTML = html;\n    append(content, slice.call(container.childNodes));\n    return content;\n  } :\n  (node, html) => {\n    const content = fragment(node);\n    const container = create(node, 'div');\n    container.innerHTML = '<svg xmlns=\"' + SVG_NAMESPACE + '\">' + html + '</svg>';\n    append(content, slice.call(container.firstChild.childNodes));\n    return content;\n  };\n","'use strict';\nconst { append } = require('../shared/utils.js');\nconst { doc, fragment } = require('../shared/easy-dom.js');\n\nfunction Wire(childNodes) {\n  this.childNodes = childNodes;\n  this.length = childNodes.length;\n  this.first = childNodes[0];\n  this.last = childNodes[this.length - 1];\n}\nObject.defineProperty(exports, '__esModule', {value: true}).default = Wire\n\n// when a wire is inserted, all its nodes will follow\nWire.prototype.insert = function insert() {\n  const df = fragment(this.first);\n  append(df, this.childNodes);\n  return df;\n};\n\n// when a wire is removed, all its nodes must be removed as well\nWire.prototype.remove = function remove() {\n  const first = this.first;\n  const last = this.last;\n  if (this.length === 2) {\n    last.parentNode.removeChild(last);\n  } else {\n    const range = doc(first).createRange();\n    range.setStartBefore(this.childNodes[1]);\n    range.setEndAfter(last);\n    range.deleteContents();\n  }\n  return first;\n};\n","'use strict';\nconst {\n  COMMENT_NODE,\n  DOCUMENT_FRAGMENT_NODE,\n  ELEMENT_NODE\n} = require('../shared/constants.js');\n\n// every template literal interpolation indicates\n// a precise target in the DOM the template is representing.\n// `<p id=${'attribute'}>some ${'content'}</p>`\n// hyperHTML finds only once per template literal,\n// hence once per entire application life-cycle,\n// all nodes that are related to interpolations.\n// These nodes are stored as indexes used to retrieve,\n// once per upgrade, nodes that will change on each future update.\n// A path example is [2, 0, 1] representing the operation:\n// node.childNodes[2].childNodes[0].childNodes[1]\n// Attributes are addressed via their owner node and their name.\nconst createPath = node => {\n  const path = [];\n  let parentNode;\n  switch (node.nodeType) {\n    case ELEMENT_NODE:\n    case DOCUMENT_FRAGMENT_NODE:\n      parentNode = node;\n      break;\n    case COMMENT_NODE:\n      parentNode = node.parentNode;\n      prepend(path, parentNode, node);\n      break;\n    default:\n      parentNode = node.ownerElement;\n      break;\n  }\n  for (\n    node = parentNode;\n    (parentNode = parentNode.parentNode);\n    node = parentNode\n  ) {\n    prepend(path, parentNode, node);\n  }\n  return path;\n};\n\nconst prepend = (path, parent, node) => {\n  path.unshift(path.indexOf.call(parent.childNodes, node));\n};\n\nObject.defineProperty(exports, '__esModule', {value: true}).default = {\n  create: (type, node, name) => ({type, name, node, path: createPath(node)}),\n  find: (node, path) => {\n    const length = path.length;\n    for (let i = 0; i < length; i++) {\n      node = node.childNodes[path[i]];\n    }\n    return node;\n  }\n}\n","'use strict';\n// from https://github.com/developit/preact/blob/33fc697ac11762a1cb6e71e9847670d047af7ce5/src/constants.js\nconst IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;\n\n// style is handled as both string and object\n// even if the target is an SVG element (consistency)\nObject.defineProperty(exports, '__esModule', {value: true}).default = (node, original, isSVG) => {\n  if (isSVG) {\n    const style = original.cloneNode(true);\n    style.value = '';\n    node.setAttributeNode(style);\n    return update(style, isSVG);\n  }\n  return update(node.style, isSVG);\n};\n\n// the update takes care or changing/replacing\n// only properties that are different or\n// in case of string, the whole node\nconst update = (style, isSVG) => {\n  let oldType, oldValue;\n  return newValue => {\n    switch (typeof newValue) {\n      case 'object':\n        if (newValue) {\n          if (oldType === 'object') {\n            if (!isSVG) {\n              if (oldValue !== newValue) {\n                for (const key in oldValue) {\n                  if (!(key in newValue)) {\n                    style[key] = '';\n                  }\n                }\n              }\n            }\n          } else {\n            if (isSVG) style.value = '';\n            else style.cssText = '';\n          }\n          const info = isSVG ? {} : style;\n          for (const key in newValue) {\n            const value = newValue[key];\n            info[key] = typeof value === 'number' &&\n                        !IS_NON_DIMENSIONAL.test(key) ?\n                          (value + 'px') : value;\n          }\n          oldType = 'object';\n          if (isSVG) style.value = toStyle((oldValue = info));\n          else oldValue = newValue;\n          break;\n        }\n      default:\n        if (oldValue != newValue) {\n          oldType = 'string';\n          oldValue = newValue;\n          if (isSVG) style.value = newValue || '';\n          else style.cssText = newValue || '';\n        }\n        break;\n    }\n  };\n};\n\nconst hyphen = /([^A-Z])([A-Z]+)/g;\nconst ized = ($0, $1, $2) => $1 + '-' + $2.toLowerCase();\nconst toStyle = object => {\n  const css = [];\n  for (const key in object) {\n    css.push(key.replace(hyphen, ized), ':', object[key], ';');\n  }\n  return css.join('');\n};","'use strict';\n/* AUTOMATICALLY IMPORTED, DO NOT MODIFY */\n/*! (c) 2017 Andrea Giammarchi (ISC) */\n\n/**\n * This code is a revisited port of the snabbdom vDOM diffing logic,\n * the same that fuels as fork Vue.js or other libraries.\n * @credits https://github.com/snabbdom/snabbdom\n */\n\nconst identity = O => O;\n\nconst remove = (parentNode, before, after) => {\n  const range = parentNode.ownerDocument.createRange();\n  range.setStartBefore(before);\n  range.setEndAfter(after);\n  range.deleteContents();\n};\n\nconst domdiff = (\n  parentNode,     // where changes happen\n  currentNodes,   // Array of current items/nodes\n  futureNodes,    // Array of future items/nodes\n  getNode,        // optional way to retrieve a node from an item\n  beforeNode      // optional item/node to use as insertBefore delimiter\n) => {\n  const get = getNode || identity;\n  const before = beforeNode == null ? null : get(beforeNode, 0);\n  let currentStart = 0, futureStart = 0;\n  let currentEnd = currentNodes.length - 1;\n  let currentStartNode = currentNodes[0];\n  let currentEndNode = currentNodes[currentEnd];\n  let futureEnd = futureNodes.length - 1;\n  let futureStartNode = futureNodes[0];\n  let futureEndNode = futureNodes[futureEnd];\n  while (currentStart <= currentEnd && futureStart <= futureEnd) {\n    if (currentStartNode == null) {\n      currentStartNode = currentNodes[++currentStart];\n    }\n    else if (currentEndNode == null) {\n      currentEndNode = currentNodes[--currentEnd];\n    }\n    else if (futureStartNode == null) {\n      futureStartNode = futureNodes[++futureStart];\n    }\n    else if (futureEndNode == null) {\n      futureEndNode = futureNodes[--futureEnd];\n    }\n    else if (currentStartNode == futureStartNode) {\n      currentStartNode = currentNodes[++currentStart];\n      futureStartNode = futureNodes[++futureStart];\n    }\n    else if (currentEndNode == futureEndNode) {\n      currentEndNode = currentNodes[--currentEnd];\n      futureEndNode = futureNodes[--futureEnd];\n    }\n    else if (currentStartNode == futureEndNode) {\n      parentNode.insertBefore(\n        get(currentStartNode, 1),\n        get(currentEndNode, -0).nextSibling\n      );\n      currentStartNode = currentNodes[++currentStart];\n      futureEndNode = futureNodes[--futureEnd];\n    }\n    else if (currentEndNode == futureStartNode) {\n      parentNode.insertBefore(\n        get(currentEndNode, 1),\n        get(currentStartNode, 0)\n      );\n      currentEndNode = currentNodes[--currentEnd];\n      futureStartNode = futureNodes[++futureStart];\n    }\n    else {\n      let index = currentNodes.indexOf(futureStartNode);\n      if (index < 0) {\n        parentNode.insertBefore(\n          get(futureStartNode, 1),\n          get(currentStartNode, 0)\n        );\n        futureStartNode = futureNodes[++futureStart];\n      }\n      else {\n        let i = index;\n        let f = futureStart;\n        while (\n          i <= currentEnd &&\n          f <= futureEnd &&\n          currentNodes[i] === futureNodes[f]\n        ) {\n          i++;\n          f++;\n        }\n        if (1 < (i - index)) {\n          if (--index === currentStart) {\n            parentNode.removeChild(get(currentStartNode, -1));\n          } else {\n            remove(\n              parentNode,\n              get(currentStartNode, -1),\n              get(currentNodes[index], -1)\n            );\n          }\n          currentStart = i;\n          futureStart = f;\n          currentStartNode = currentNodes[i];\n          futureStartNode = futureNodes[f];\n        } else {\n          const el = currentNodes[index];\n          currentNodes[index] = null;\n          parentNode.insertBefore(get(el, 1), get(currentStartNode, 0));\n          futureStartNode = futureNodes[++futureStart];\n        }\n      }\n    }\n  }\n  if (currentStart <= currentEnd || futureStart <= futureEnd) {\n    if (currentStart > currentEnd) {\n      const pin = futureNodes[futureEnd + 1];\n      const place = pin == null ? before : get(pin, 0);\n      if (futureStart === futureEnd) {\n        parentNode.insertBefore(get(futureNodes[futureStart], 1), place);\n      }\n      else {\n        const fragment = parentNode.ownerDocument.createDocumentFragment();\n        while (futureStart <= futureEnd) {\n          fragment.appendChild(get(futureNodes[futureStart++], 1));\n        }\n        parentNode.insertBefore(fragment, place);\n      }\n    }\n    else {\n      if (currentNodes[currentStart] == null) currentStart++;\n      if (currentStart === currentEnd) {\n        parentNode.removeChild(get(currentNodes[currentStart], -1));\n      }\n      else {\n        remove(\n          parentNode,\n          get(currentNodes[currentStart], -1),\n          get(currentNodes[currentEnd], -1)\n        );\n      }\n    }\n  }\n  return futureNodes;\n};\n\nObject.defineProperty(exports, '__esModule', {value: true}).default = domdiff;\n","'use strict';\nconst {\n  CONNECTED, DISCONNECTED, COMMENT_NODE, DOCUMENT_FRAGMENT_NODE, ELEMENT_NODE, TEXT_NODE, OWNER_SVG_ELEMENT, SHOULD_USE_TEXT_CONTENT, UID, UIDC\n} = require('../shared/constants.js');\n\nconst Component = (m => m.__esModule ? m.default : m)(require('../classes/Component.js'));\nconst Wire = (m => m.__esModule ? m.default : m)(require('../classes/Wire.js'));\nconst Path = (m => m.__esModule ? m.default : m)(require('./Path.js'));\nconst Style = (m => m.__esModule ? m.default : m)(require('./Style.js'));\nconst Intent = (m => m.__esModule ? m.default : m)(require('./Intent.js'));\nconst domdiff = (m => m.__esModule ? m.default : m)(require('../shared/domdiff.js'));\n// see /^script$/i.test(nodeName) bit down here\n// import { create as createElement, text } from '../shared/easy-dom.js';\nconst { text } = require('../shared/easy-dom.js');\nconst { Event, WeakSet, isArray, trim } = require('../shared/poorlyfills.js');\nconst { createFragment, slice } = require('../shared/utils.js');\n\n// hyper.Component have a connected/disconnected\n// mechanism provided by MutationObserver\n// This weak set is used to recognize components\n// as DOM node that needs to trigger connected/disconnected events\nconst components = new WeakSet;\n\n// a basic dictionary used to filter already cached attributes\n// while looking for special hyperHTML values.\nfunction Cache() {}\nCache.prototype = Object.create(null);\n\n// returns an intent to explicitly inject content as html\nconst asHTML = html => ({html});\n\n// returns nodes from wires and components\nconst asNode = (item, i) => {\n  return 'ELEMENT_NODE' in item ?\n    item :\n    (item.constructor === Wire ?\n      // in the Wire case, the content can be\n      // removed, post-pended, inserted, or pre-pended and\n      // all these cases are handled by domdiff already\n      /* istanbul ignore next */\n      ((1 / i) < 0 ?\n        (i ? item.remove() : item.last) :\n        (i ? item.insert() : item.first)) :\n      asNode(item.render(), i));\n}\n\n// returns true if domdiff can handle the value\nconst canDiff = value =>  'ELEMENT_NODE' in value ||\nvalue instanceof Wire ||\nvalue instanceof Component;\n\n// updates are created once per context upgrade\n// within the main render function (../hyper/render.js)\n// These are an Array of callbacks to invoke passing\n// each interpolation value.\n// Updates can be related to any kind of content,\n// attributes, or special text-only cases such <style>\n// elements or <textarea>\nconst create = (root, paths) => {\n  const updates = [];\n  const length = paths.length;\n  for (let i = 0; i < length; i++) {\n    const info = paths[i];\n    const node = Path.find(root, info.path);\n    switch (info.type) {\n      case 'any':\n        updates.push(setAnyContent(node, []));\n        break;\n      case 'attr':\n        updates.push(setAttribute(node, info.name, info.node));\n        break;\n      case 'text':\n        updates.push(setTextContent(node));\n        node.textContent = '';\n        break;\n    }\n  }\n  return updates;\n};\n\n// finding all paths is a one-off operation performed\n// when a new template literal is used.\n// The goal is to map all target nodes that will be\n// used to update content/attributes every time\n// the same template literal is used to create content.\n// The result is a list of paths related to the template\n// with all the necessary info to create updates as\n// list of callbacks that target directly affected nodes.\nconst find = (node, paths, parts) => {\n  const childNodes = node.childNodes;\n  const length = childNodes.length;\n  for (let i = 0; i < length; i++) {\n    let child = childNodes[i];\n    switch (child.nodeType) {\n      case ELEMENT_NODE:\n        findAttributes(child, paths, parts);\n        find(child, paths, parts);\n        break;\n      case COMMENT_NODE:\n        if (child.textContent === UID) {\n          parts.shift();\n          paths.push(\n            // basicHTML or other non standard engines\n            // might end up having comments in nodes\n            // where they shouldn't, hence this check.\n            SHOULD_USE_TEXT_CONTENT.test(node.nodeName) ?\n              Path.create('text', node) :\n              Path.create('any', child)\n          );\n        }\n        break;\n      case TEXT_NODE:\n        // the following ignore is actually covered by browsers\n        // only basicHTML ends up on previous COMMENT_NODE case\n        // instead of TEXT_NODE because it knows nothing about\n        // special style or textarea behavior\n        /* istanbul ignore if */\n        if (\n          SHOULD_USE_TEXT_CONTENT.test(node.nodeName) &&\n          trim.call(child.textContent) === UIDC\n        ) {\n          parts.shift();\n          paths.push(Path.create('text', node));\n        }\n        break;\n    }\n  }\n};\n\n// attributes are searched via unique hyperHTML id value.\n// Despite HTML being case insensitive, hyperHTML is able\n// to recognize attributes by name in a caseSensitive way.\n// This plays well with Custom Elements definitions\n// and also with XML-like environments, without trusting\n// the resulting DOM but the template literal as the source of truth.\n// IE/Edge has a funny bug with attributes and these might be duplicated.\n// This is why there is a cache in charge of being sure no duplicated\n// attributes are ever considered in future updates.\nconst findAttributes = (node, paths, parts) => {\n  const cache = new Cache;\n  const attributes = node.attributes;\n  const array = slice.call(attributes);\n  const remove = [];\n  const length = array.length;\n  for (let i = 0; i < length; i++) {\n    const attribute = array[i];\n    if (attribute.value === UID) {\n      const name = attribute.name;\n      // the following ignore is covered by IE\n      // and the IE9 double viewBox test\n      /* istanbul ignore else */\n      if (!(name in cache)) {\n        const realName = parts.shift().replace(/^(?:|[\\S\\s]*?\\s)(\\S+?)=['\"]?$/, '$1');\n        cache[name] = attributes[realName] ||\n                      // the following ignore is covered by browsers\n                      // while basicHTML is already case-sensitive\n                      /* istanbul ignore next */\n                      attributes[realName.toLowerCase()];\n        paths.push(Path.create('attr', cache[name], realName));\n      }\n      remove.push(attribute);\n    }\n  }\n  const len = remove.length;\n  for (let i = 0; i < len; i++) {\n    // Edge HTML bug #16878726\n    const attribute = remove[i];\n    if (/^id$/i.test(attribute.name))\n      node.removeAttribute(attribute.name);\n    // standard browsers would work just fine here\n    else\n      node.removeAttributeNode(remove[i]);\n  }\n\n  // This is a very specific Firefox/Safari issue\n  // but since it should be a not so common pattern,\n  // it's probably worth patching regardless.\n  // Basically, scripts created through strings are death.\n  // You need to create fresh new scripts instead.\n  // TODO: is there any other node that needs such nonsense?\n  const nodeName = node.nodeName;\n  if (/^script$/i.test(nodeName)) {\n    // this used to be like that\n    // const script = createElement(node, nodeName);\n    // then Edge arrived and decided that scripts created\n    // through template documents aren't worth executing\n    // so it became this ... hopefully it won't hurt in the wild\n    const script = document.createElement(nodeName);\n    for (let i = 0; i < attributes.length; i++) {\n      script.setAttributeNode(attributes[i].cloneNode(true));\n    }\n    script.textContent = node.textContent;\n    node.parentNode.replaceChild(script, node);\n  }\n};\n\n// when a Promise is used as interpolation value\n// its result must be parsed once resolved.\n// This callback is in charge of understanding what to do\n// with a returned value once the promise is resolved.\nconst invokeAtDistance = (value, callback) => {\n  callback(value.placeholder);\n  if ('text' in value) {\n    Promise.resolve(value.text).then(String).then(callback);\n  } else if ('any' in value) {\n    Promise.resolve(value.any).then(callback);\n  } else if ('html' in value) {\n    Promise.resolve(value.html).then(asHTML).then(callback);\n  } else {\n    Promise.resolve(Intent.invoke(value, callback)).then(callback);\n  }\n};\n\n// quick and dirty way to check for Promise/ish values\nconst isPromise_ish = value => value != null && 'then' in value;\n\n// in a hyper(node)`<div>${content}</div>` case\n// everything could happen:\n//  * it's a JS primitive, stored as text\n//  * it's null or undefined, the node should be cleaned\n//  * it's a component, update the content by rendering it\n//  * it's a promise, update the content once resolved\n//  * it's an explicit intent, perform the desired operation\n//  * it's an Array, resolve all values if Promises and/or\n//    update the node with the resulting list of content\nconst setAnyContent = (node, childNodes) => {\n  let fastPath = false;\n  let oldValue;\n  const anyContent = value => {\n    switch (typeof value) {\n      case 'string':\n      case 'number':\n      case 'boolean':\n        if (fastPath) {\n          if (oldValue !== value) {\n            oldValue = value;\n            childNodes[0].textContent = value;\n          }\n        } else {\n          fastPath = true;\n          oldValue = value;\n          childNodes = domdiff(\n            node.parentNode,\n            childNodes,\n            [text(node, value)],\n            asNode,\n            node\n          );\n        }\n        break;\n      case 'object':\n      case 'undefined':\n        if (value == null) {\n          fastPath = false;\n          childNodes = domdiff(\n            node.parentNode,\n            childNodes,\n            [],\n            asNode,\n            node\n          );\n          break;\n        }\n      default:\n        fastPath = false;\n        oldValue = value;\n        if (isArray(value)) {\n          if (value.length === 0) {\n            if (childNodes.length) {\n              childNodes = domdiff(\n                node.parentNode,\n                childNodes,\n                [],\n                asNode,\n                node\n              );\n            }\n          } else {\n            switch (typeof value[0]) {\n              case 'string':\n              case 'number':\n              case 'boolean':\n                anyContent({html: value});\n                break;\n              case 'object':\n                if (isArray(value[0])) {\n                  value = value.concat.apply([], value);\n                }\n                if (isPromise_ish(value[0])) {\n                  Promise.all(value).then(anyContent);\n                  break;\n                }\n              default:\n                childNodes = domdiff(\n                  node.parentNode,\n                  childNodes,\n                  value,\n                  asNode,\n                  node\n                );\n                break;\n            }\n          }\n        } else if (canDiff(value)) {\n          childNodes = domdiff(\n            node.parentNode,\n            childNodes,\n            value.nodeType === DOCUMENT_FRAGMENT_NODE ?\n              slice.call(value.childNodes) :\n              [value],\n            asNode,\n            node\n          );\n        } else if (isPromise_ish(value)) {\n          value.then(anyContent);\n        } else if ('placeholder' in value) {\n          invokeAtDistance(value, anyContent);\n        } else if ('text' in value) {\n          anyContent(String(value.text));\n        } else if ('any' in value) {\n          anyContent(value.any);\n        } else if ('html' in value) {\n          childNodes = domdiff(\n            node.parentNode,\n            childNodes,\n            slice.call(\n              createFragment(\n                node,\n                [].concat(value.html).join('')\n              ).childNodes\n            ),\n            asNode,\n            node\n          );\n        } else if ('length' in value) {\n          anyContent(slice.call(value));\n        } else {\n          anyContent(Intent.invoke(value, anyContent));\n        }\n        break;\n    }\n  };\n  return anyContent;\n};\n\n// there are four kind of attributes, and related behavior:\n//  * events, with a name starting with `on`, to add/remove event listeners\n//  * special, with a name present in their inherited prototype, accessed directly\n//  * regular, accessed through get/setAttribute standard DOM methods\n//  * style, the only regular attribute that also accepts an object as value\n//    so that you can style=${{width: 120}}. In this case, the behavior has been\n//    fully inspired by Preact library and its simplicity.\nconst setAttribute = (node, name, original) => {\n  const isSVG = OWNER_SVG_ELEMENT in node;\n  let oldValue;\n  // if the attribute is the style one\n  // handle it differently from others\n  if (name === 'style') {\n    return Style(node, original, isSVG);\n  }\n  // the name is an event one,\n  // add/remove event listeners accordingly\n  else if (/^on/.test(name)) {\n    let type = name.slice(2);\n    if (type === CONNECTED || type === DISCONNECTED) {\n      if (notObserving) {\n        notObserving = false;\n        observe();\n      }\n      components.add(node);\n    }\n    else if (name.toLowerCase() in node) {\n      type = type.toLowerCase();\n    }\n    return newValue => {\n      if (oldValue !== newValue) {\n        if (oldValue) node.removeEventListener(type, oldValue, false);\n        oldValue = newValue;\n        if (newValue) node.addEventListener(type, newValue, false);\n      }\n    };\n  }\n  // the attribute is special ('value' in input)\n  // and it's not SVG *or* the name is exactly data,\n  // in this case assign the value directly\n  else if (name === 'data' || (!isSVG && name in node)) {\n    return newValue => {\n      if (oldValue !== newValue) {\n        oldValue = newValue;\n        if (node[name] !== newValue) {\n          node[name] = newValue;\n          if (newValue == null) {\n            node.removeAttribute(name);\n          }\n        }\n      }\n    };\n  }\n  // in every other case, use the attribute node as it is\n  // update only the value, set it as node only when/if needed\n  else {\n    let owner = false;\n    const attribute = original.cloneNode(true);\n    return newValue => {\n      if (oldValue !== newValue) {\n        oldValue = newValue;\n        if (attribute.value !== newValue) {\n          if (newValue == null) {\n            if (owner) {\n              owner = false;\n              node.removeAttributeNode(attribute);\n            }\n            attribute.value = newValue;\n          } else {\n            attribute.value = newValue;\n            if (!owner) {\n              owner = true;\n              node.setAttributeNode(attribute);\n            }\n          }\n        }\n      }\n    };\n  }\n};\n\n// style or textareas don't accept HTML as content\n// it's pointless to transform or analyze anything\n// different from text there but it's worth checking\n// for possible defined intents.\nconst setTextContent = node => {\n  let oldValue;\n  const textContent = value => {\n    if (oldValue !== value) {\n      oldValue = value;\n      if (typeof value === 'object' && value) {\n        if (isPromise_ish(value)) {\n          value.then(textContent);\n        } else if ('placeholder' in value) {\n          invokeAtDistance(value, textContent);\n        } else if ('text' in value) {\n          textContent(String(value.text));\n        } else if ('any' in value) {\n          textContent(value.any);\n        } else if ('html' in value) {\n          textContent([].concat(value.html).join(''));\n        } else if ('length' in value) {\n          textContent(slice.call(value).join(''));\n        } else {\n          textContent(Intent.invoke(value, textContent));\n        }\n      } else {\n        node.textContent = value == null ? '' : value;\n      }\n    }\n  };\n  return textContent;\n};\n\nObject.defineProperty(exports, '__esModule', {value: true}).default = {create, find};\n\n// hyper.Components might need connected/disconnected notifications\n// used by components and their onconnect/ondisconnect callbacks.\n// When one of these callbacks is encountered,\n// the document starts being observed.\nlet notObserving = true;\nfunction observe() {\n\n  // when hyper.Component related DOM nodes\n  // are appended or removed from the live tree\n  // these might listen to connected/disconnected events\n  // This utility is in charge of finding all components\n  // involved in the DOM update/change and dispatch\n  // related information to them\n  const dispatchAll = (nodes, type) => {\n    const event = new Event(type);\n    const length = nodes.length;\n    for (let i = 0; i < length; i++) {\n      let node = nodes[i];\n      if (node.nodeType === ELEMENT_NODE) {\n        dispatchTarget(node, event);\n      }\n    }\n  };\n\n  // the way it's done is via the components weak set\n  // and recursively looking for nested components too\n  const dispatchTarget = (node, event) => {\n    if (components.has(node)) {\n      node.dispatchEvent(event);\n    }\n\n    const children = node.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      dispatchTarget(children[i], event);\n    }\n  }\n\n  // The MutationObserver is the best way to implement that\n  // but there is a fallback to deprecated DOMNodeInserted/Removed\n  // so that even older browsers/engines can help components life-cycle\n  try {\n    (new MutationObserver(records => {\n      const length = records.length;\n      for (let i = 0; i < length; i++) {\n        let record = records[i];\n        dispatchAll(record.removedNodes, DISCONNECTED);\n        dispatchAll(record.addedNodes, CONNECTED);\n      }\n    })).observe(document, {subtree: true, childList: true});\n  } catch(o_O) {\n    document.addEventListener('DOMNodeRemoved', event => {\n      dispatchAll([event.target], DISCONNECTED);\n    }, false);\n    document.addEventListener('DOMNodeInserted', event => {\n      dispatchAll([event.target], CONNECTED);\n    }, false);\n  }\n}\n","'use strict';\nconst {Map, WeakMap} = require('../shared/poorlyfills.js');\nconst {UIDC, VOID_ELEMENTS} = require('../shared/constants.js');\nconst Updates = (m => m.__esModule ? m.default : m)(require('../objects/Updates.js'));\nconst {\n  createFragment,\n  importNode,\n  unique\n} = require('../shared/utils.js');\n\nconst {selfClosing} = require('../shared/re.js');\n\n// a weak collection of contexts that\n// are already known to hyperHTML\nconst bewitched = new WeakMap;\n\n// the collection of all template literals\n// since these are unique and immutable\n// for the whole application life-cycle\nconst templates = new Map;\n\n// better known as hyper.bind(node), the render is\n// the main tag function in charge of fully upgrading\n// or simply updating, contexts used as hyperHTML targets.\n// The `this` context is either a regular DOM node or a fragment.\nfunction render(template) {\n  const wicked = bewitched.get(this);\n  if (wicked && wicked.template === unique(template)) {\n    update.apply(wicked.updates, arguments);\n  } else {\n    upgrade.apply(this, arguments);\n  }\n  return this;\n}\n\n// an upgrade is in charge of collecting template info,\n// parse it once, if unknown, to map all interpolations\n// as single DOM callbacks, relate such template\n// to the current context, and render it after cleaning the context up\nfunction upgrade(template) {\n  template = unique(template);\n  const info =  templates.get(template) ||\n                createTemplate.call(this, template);\n  const fragment = importNode(this.ownerDocument, info.fragment);\n  const updates = Updates.create(fragment, info.paths);\n  bewitched.set(this, {template, updates});\n  update.apply(updates, arguments);\n  this.textContent = '';\n  this.appendChild(fragment);\n}\n\n// an update simply loops over all mapped DOM operations\nfunction update() {\n  const length = arguments.length;\n  for (let i = 1; i < length; i++) {\n    this[i - 1](arguments[i]);\n  }\n}\n\n// a template can be used to create a document fragment\n// aware of all interpolations and with a list\n// of paths used to find once those nodes that need updates,\n// no matter if these are attributes, text nodes, or regular one\nfunction createTemplate(template) {\n  const paths = [];\n  const html = template.join(UIDC).replace(SC_RE, SC_PLACE);\n  const fragment = createFragment(this, html);\n  Updates.find(fragment, paths, template.slice());\n  const info = {fragment, paths};\n  templates.set(template, info);\n  return info;\n}\n\n// some node could be special though, like a custom element\n// with a self closing tag, which should work through these changes.\nconst SC_RE = selfClosing;\nconst SC_PLACE = ($0, $1, $2) => {\n  return VOID_ELEMENTS.test($1) ? $0 : ('<' + $1 + $2 + '></' + $1 + '>');\n};\n\nObject.defineProperty(exports, '__esModule', {value: true}).default = render;\n","'use strict';\nconst {ELEMENT_NODE, SVG_NAMESPACE} = require('../shared/constants.js');\nconst {WeakMap, trim} = require('../shared/poorlyfills.js');\nconst {fragment} = require('../shared/easy-dom.js');\nconst {append, slice, unique} = require('../shared/utils.js');\nconst Wire = (m => m.__esModule ? m.default : m)(require('../classes/Wire.js'));\nconst render = (m => m.__esModule ? m.default : m)(require('./render.js'));\n\n// all wires used per each context\nconst wires = new WeakMap;\n\n// A wire is a callback used as tag function\n// to lazily relate a generic object to a template literal.\n// hyper.wire(user)`<div id=user>${user.name}</div>`; => the div#user\n// This provides the ability to have a unique DOM structure\n// related to a unique JS object through a reusable template literal.\n// A wire can specify a type, as svg or html, and also an id\n// via html:id or :id convention. Such :id allows same JS objects\n// to be associated to different DOM structures accordingly with\n// the used template literal without losing previously rendered parts.\nconst wire = (obj, type) => obj == null ?\n  content(type || 'html') :\n  weakly(obj, type || 'html');\n\n// A wire content is a virtual reference to one or more nodes.\n// It's represented by either a DOM node, or an Array.\n// In both cases, the wire content role is to simply update\n// all nodes through the list of related callbacks.\n// In few words, a wire content is like an invisible parent node\n// in charge of updating its content like a bound element would do.\nconst content = type => {\n  let wire, container, content, template, updates;\n  return function (statics) {\n    statics = unique(statics);\n    let setup = template !== statics;\n    if (setup) {\n      template = statics;\n      content = fragment(document);\n      container = type === 'svg' ?\n        document.createElementNS(SVG_NAMESPACE, 'svg') :\n        content;\n      updates = render.bind(container);\n    }\n    updates.apply(null, arguments);\n    if (setup) {\n      if (type === 'svg') {\n        append(content, slice.call(container.childNodes));\n      }\n      wire = wireContent(content);\n    }\n    return wire;\n  };\n};\n\n// wires are weakly created through objects.\n// Each object can have multiple wires associated\n// and this is thanks to the type + :id feature.\nconst weakly = (obj, type) => {\n  const i = type.indexOf(':');\n  let wire = wires.get(obj);\n  let id = type;\n  if (-1 < i) {\n    id = type.slice(i + 1);\n    type = type.slice(0, i) || 'html';\n  }\n  if (!wire) wires.set(obj, wire = {});\n  return wire[id] || (wire[id] = content(type));\n};\n\n// a document fragment loses its nodes as soon\n// as it's appended into another node.\n// This would easily lose wired content\n// so that on a second render call, the parent\n// node wouldn't know which node was there\n// associated to the interpolation.\n// To prevent hyperHTML to forget about wired nodes,\n// these are either returned as Array or, if there's ony one entry,\n// as single referenced node that won't disappear from the fragment.\n// The initial fragment, at this point, would be used as unique reference.\nconst wireContent = node => {\n  const childNodes = node.childNodes;\n  const length = childNodes.length;\n  const wireNodes = [];\n  for (let i = 0; i < length; i++) {\n    let child = childNodes[i];\n    if (\n      child.nodeType === ELEMENT_NODE ||\n      trim.call(child.textContent).length !== 0\n    ) {\n      wireNodes.push(child);\n    }\n  }\n  return wireNodes.length === 1 ? wireNodes[0] : new Wire(wireNodes);\n};\n\nexports.content = content;\nexports.weakly = weakly;\nObject.defineProperty(exports, '__esModule', {value: true}).default = wire;\n","'use strict';\n/*! (c) Andrea Giammarchi (ISC) */\n\nconst Component = (m => m.__esModule ? m.default : m)(require('./classes/Component.js'));\nconst {setup} = require('./classes/Component.js');\nconst Intent = (m => m.__esModule ? m.default : m)(require('./objects/Intent.js'));\nconst wire = (m => m.__esModule ? m.default : m)(require('./hyper/wire.js'));\nconst {content, weakly} = require('./hyper/wire.js');\nconst render = (m => m.__esModule ? m.default : m)(require('./hyper/render.js'));\nconst diff = (m => m.__esModule ? m.default : m)(require('./shared/domdiff.js'));\n\n// all functions are self bound to the right context\n// you can do the following\n// const {bind, wire} = hyperHTML;\n// and use them right away: bind(node)`hello!`;\nconst bind = context => render.bind(context);\nconst define = Intent.define;\n\nhyper.Component = Component;\nhyper.bind = bind;\nhyper.define = define;\nhyper.diff = diff;\nhyper.hyper = hyper;\nhyper.wire = wire;\n\n// the wire content is the lazy defined\n// html or svg property of each hyper.Component\nsetup(content);\n\n// everything is exported directly or through the\n// hyperHTML callback, when used as top level script\nexports.Component = Component;\nexports.bind = bind;\nexports.define = define;\nexports.diff = diff;\nexports.hyper = hyper;\nexports.wire = wire;\n\n// by default, hyperHTML is a smart function\n// that \"magically\" understands what's the best\n// thing to do with passed arguments\nfunction hyper(HTML) {\n  return arguments.length < 2 ?\n    (HTML == null ?\n      content('html') :\n      (typeof HTML === 'string' ?\n        hyper.wire(null, HTML) :\n        ('raw' in HTML ?\n          content('html')(HTML) :\n          ('nodeType' in HTML ?\n            hyper.bind(HTML) :\n            weakly(HTML, 'html')\n          )\n        )\n      )) :\n    ('raw' in HTML ?\n      content('html') : hyper.wire\n    ).apply(null, arguments);\n}\nObject.defineProperty(exports, '__esModule', {value: true}).default = hyper\n","module.exports = {\n  //\n  /**\n   * @param {HTMLElement} el el\n   * @param {String} type type\n   * @param {Object} payload payload\n   * @returns {void} v\n   */\n  send(el, type, payload) {\n    el.dispatchEvent(new CustomEvent(type, payload));\n  },\n  //\n  /**\n   * @param {HTMLElement} el el\n   * @param {String} type type\n   * @param {Function} cb cb\n   * @returns {void} v\n   */\n  recv(el, type, cb) {\n    el.addEventListener(type, cb);\n  }\n};\n","module.exports = (val, type) => val.constructor === type;\r\n","module.exports = (val, def) => {\r\n  try {\r\n    return (require(\"./is\")(val, Function) ? val() : val) || def;\r\n  } catch (e) {\r\n    return def;\r\n  }\r\n};\r\n","const { Component } = require(\"hyperhtml/cjs\");\r\nconst result = require(\"../helper/result\");\r\n\r\nmodule.exports = class ArrowPad extends Component {\r\n  constructor(args) {\r\n    super().props = args;\r\n  }\r\n  get defaultState() {\r\n    return Object.assign({ count: 0 }, this.props);\r\n  }\r\n  doAThing(e, action) {\r\n    setTimeout(() => this.setState({ count: ++this.state.count }), 500);\r\n    this.setState({ action });\r\n    result(e.target, document.getElementById(\"root\")).dispatchEvent(\r\n      new CustomEvent(\"awesome\", {\r\n        bubbles: true,\r\n        detail: { text: () => Math.random() }\r\n      })\r\n    );\r\n  }\r\n\r\n  render() {\r\n    return this.html`\r\n      <button onclick=\"${e => this.doAThing(e, \" - LEFT\")}\"></button>\r\n      <button onclick=\"${e => this.doAThing(e, \" - UP\")}\"></button>\r\n      <button onclick=\"${e => this.doAThing(e, \" - BOTTOM\")}\"></button>\r\n      <button onclick=\"${e => this.doAThing(e, \" - RIGHT\")}\"></button>\r\n      <p>Last action: ${this.state.action}</p>\r\n      <p>Counter: ${this.state.count}</p>\r\n    `;\r\n  }\r\n};\r\n","const { Component } = require(\"hyperhtml/cjs\");\r\n\r\nmodule.exports = class ArrowPad extends Component {\r\n  constructor(args) {\r\n    super().props = args;\r\n\r\n    /** @returns {void} */\r\n    const tick = () => {\r\n      this.setState({ date: new Date() });\r\n      setTimeout(tick, 50);\r\n    };\r\n\r\n    tick();\r\n  }\r\n  get defaultState() {\r\n    return Object.assign({}, this.props);\r\n  }\r\n\r\n  render() {\r\n    return this.html`\r\n      <div>\r\n        <h1>Hello, world!</h1>\r\n        <h2>It is ${this.state.date.toLocaleTimeString()}.</h2>\r\n      </div>\r\n    `;\r\n  }\r\n};\r\n","const { Component } = require(\"hyperhtml/cjs\");\n// const { log: clog } = console;\n\nclass ListItem extends Component {\n  constructor(args) {\n    super().props = args;\n    this.setState(this.props);\n  }\n\n  get defaultState() {\n    return {\n      listItemStyle: {}\n    };\n  }\n\n  render() {\n    // clog(\"LI\", this.state.listItemStyle);\n\n    return this.html`\n      <li style=\"${this.state.listItemStyle}\">${this.state.item}</li>\n    `;\n  }\n}\n\nmodule.exports = class List extends Component {\n  constructor(args) {\n    super().props = args;\n    // this.setState(\n    //   Object.assign(\n    //     {\n    //       tag: \"UL\",\n    //       listItems: [],\n    //       listStyle: {},\n    //       listItemStyle: {}\n    //     },\n    //     args\n    //   )\n    // );\n  }\n\n  get defaultState() {\n    return (\n      this.props || {\n        tag: \"UL\",\n        listItems: [],\n        listStyle: {},\n        listItemStyle: {}\n      }\n    );\n  }\n\n  render() {\n    // clog(\"UL\", this.state.listItems);\n\n    const li = this.state.listItems.map($ => {\n      $.listItemStyle = this.state.listItemStyle;\n\n      return ListItem.for($);\n    });\n\n    return this.state.tag.toUpperCase() === \"UL\"\n      ? this.html`<ul style=\"${this.state.listStyle}\">${li}</ul>`\n      : this.html`<ol style=\"${this.state.listStyle}\">${li}</ol>`;\n  }\n};\n","const { Component } = require(\"hyperhtml/cjs\");\nconst List = require(\"./List\");\n// const { log: clog } = console;\n\nmodule.exports = class Header extends Component {\n  constructor(args) {\n    super().props = args;\n    this.setState(this.props);\n  }\n\n  get defaultState() {\n    return {\n      listItems: []\n    };\n  }\n\n  render() {\n    // clog(\"HEADER\", this.state.listItems);\n\n    return this.html`\n      <header\n        class=\"clear\"\n        style=\"${{ background: \"#f009\" }}\"\n      >\n        ${new List({\n          tag: \"UL\",\n          listItems: this.state.listItems,\n          listStyle: { display: \"inline-block\", margin: 0, padding: 0 },\n          listItemStyle: { display: \"inline-block\" }\n        })}\n      </header>\n    `;\n  }\n};\n","const { Component } = require(\"hyperhtml/cjs\");\n// const { log: clog } = console;\n\nmodule.exports = class Link extends Component {\n  constructor(args) {\n    super().props = args;\n    this.setState(this.props);\n  }\n\n  get defaultState() {\n    return {\n      style: {\n        display: \"inline-block\",\n        padding: \".5em .25em\"\n      },\n      text: null,\n      href: \"#\",\n      click: () => {}\n    };\n  }\n\n  render() {\n    // clog(\"A\", this.state.href);\n\n    return this.html`\n      <a\n        style=\"${this.state.style}\"\n        href=\"${this.state.href}\"\n        onclick=\"${this.state.click}\"\n      >${this.state.text}</a>\n    `;\n  }\n};\n","// /** @returns {void} */\n// const noop = () => {};\nconst { log: clog } = console;\nconst d = document;\n\nd.root = d.getElementById(\"root\");\n// const bind = require(\"hyperhtml/cjs\").hyper(d.root);\nconst app = require(\"hyperhtml-app\")();\nconst { Component, bind } = require(\"hyperhtml/cjs\");\n\nconst signal = require(\"./helper/signal\");\nconst result = require(\"./helper/result\");\nconst ArrowPad = require(\"./component/ArrowPad\");\nconst Clock = require(\"./component/Clock\");\nconst Header = require(\"./component/Header\");\nconst Link = require(\"./component/Link\");\n\nconst URI = \"http://localhost:4000\";\n\nclass App extends Component {\n  constructor() {\n    super();\n    fetch(`${URI}/api/pages.json`)\n      .then(b => b.json())\n      .then(b =>\n        b\n          .filter(b => b.permalink && b.menu_index >= 0)\n          .sort((a, b) => a.menu_index - b.menu_index)\n          .map(b => ({\n            item: Link.for({\n              text: b.title,\n              href: b.url,\n              click: e => {\n                // signal.send(d.root, \"navigate\", {\n                //   detail: { e, route: b.url }\n                // });\n                clog(e);\n                this.setState({ route: b.url });\n                app.navigate(b.url);\n              }\n            })\n          }))\n      )\n      .then(b => {\n        this.setState({ listItems: b });\n      });\n    signal.recv(d.root, \"navigate\", e => {\n      clog(\"navigate\", result(e.detail.route));\n      clog(\"listItems\", result(this.state.listItems));\n      // result(e.detail.route) && this.setState({ route: e.detail.route });\n    });\n  }\n\n  get defaultState() {\n    return {\n      route: \"/\",\n      html: d.getElementById(\"content\").innerHTML,\n      listItems: Array(2)\n        .fill()\n        .map((a, i) => ({\n          item: Link.for({\n            text: `#${i}`,\n            href: `#${i}`,\n            click: e => {\n              // signal.send(d.root, \"navigate\", {\n              //   detail: { e, route: `#${i}` }\n              // });\n              clog(e);\n              this.setState({ route: `#${i}` });\n              app.navigate(`#${i}`);\n            }\n          })\n        }))\n    };\n  }\n\n  render() {\n    return this.html`\n    ${new Header({ listItems: this.state.listItems })}\n    <p>${this.state.route}</p>\n    <div>\n      ${{ html: this.state.html }}\n      ${new ArrowPad({ action: \"love\" })}\n      ${new Clock({ date: new Date() })}\n    </div>\n    `;\n  }\n}\n\nbind(d.root)`${new App()}`;\n\n// app.get(\"*\", async (ctx, next) => {\n//   try {\n//     await _app.setState({ route: ctx.params[0] });\n//     clog(\"CTX >>\", ctx);\n//     clog(\"OK  >>\", _app.state);\n//   } catch (error) {\n//     clog(\"err >>\", error);\n//   }\n\n//   // return next();\n// });\n\n// app.navigate(window.location.pathname);\n\n// (async () => {\n//   await Promise.all([\n//     fetch(`${URI}/api/pages.json`)\n//       .then(b => b.json())\n//       .then(b =>\n//         b\n//           .filter(b => b.permalink && b.menu_index >= 0)\n//           .sort((a, b) => a.menu_index - b.menu_index)\n//           .map(b => ({ item: Link.for({ text: b.title, href: b.url }) }))\n//       )\n//       .then(b => {\n//         _app.setState({ listItems: b });\n//       })\n\n//     // fetch(`${URI}${ctx.params[0]}`)\n//     //   .then(b => b.text())\n//     //   .then(b => {\n//     //     const c = d.getElementById(\"content\");\n\n//     //     c.innerHTML = b;\n//     //     c.innerHTML = c.content.getElementById(\"content\").innerHTML;\n\n//     //     return c.innerHTML;\n//     //   })\n//   ]);\n\n//   // _app.setState({ listItems, html });\n// })();\n","require(\"./js/App\");\r\n"]}